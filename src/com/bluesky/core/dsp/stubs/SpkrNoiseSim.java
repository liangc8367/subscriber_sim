package com.bluesky.core.dsp.stubs;

import com.bluesky.JitterBuffer;
import com.bluesky.common.GlobalConstants;
import com.bluesky.core.dsp.SignalSink;

import java.nio.ByteBuffer;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

/** simulated spkr implementation, used to validate the data received
 *  through communication channel, which was generated by MicNoiseSim.
 *
 *  Jitterbuffer is used in processing to handle jitter
 *
 * Created by liangc on 16/03/15.
 */
public class SpkrNoiseSim implements SignalSink{

    /**
     *
     * @param executor
     */
    public SpkrNoiseSim(ScheduledExecutorService executor){
        mExecutor = executor;
    }

    /**
     *  offer data to spkr, first data (after reset() or ctor() will trigger
     *  start() operation internally.
     *
     * @param data to be total
     * @param sequence number, subclass of sink class can use sequence id to order/buffer incoming data
     * @return false if data is obsoleted according to its sequence#
     */
    @Override
    public boolean offer(ByteBuffer data, short sequence) {
        if(mStopped){
            return false;
        }
        boolean res;
        res = mJitterBuffer.offer(data, sequence);
        if( !mRunning ){
            mScheduledJob = mExecutor.scheduleAtFixedRate(
                    mJob, GlobalConstants.CALL_PACKET_INTERVAL, GlobalConstants.CALL_PACKET_INTERVAL,
                    TimeUnit.MILLISECONDS);
            mRunning = true;
        }
        return res;
    }

    @Override
    public boolean start() {
        return false;
    }

    /**
     *
     * @return false if spkr is not running
     */
    @Override
    public boolean stop() {
        if(!mRunning){
            return false;
        }
        mScheduledJob.cancel(false);
        mScheduledJob = null;
        mStopped = true;
        mRunning = false;
        if(mListener!=null){
            mListener.onEndOfLife();
        }
        return true;
    }

    /**
     *
     * @return false if sprk was not stopped
     */
    @Override
    public boolean reset() {
        if( mStopped ) {
            mJitterBuffer.reset();
            mStopped = false;
            mRunning = false;
            mSequence = 0;
            return true;
        } else {
            return false;
        }
    }

    @Override
    public boolean release() {
        return false;
    }

    @Override
    public void register(Listener listener) {
        mListener = listener;
    }

    public Stats getStats(){
        return mStats;
    }

    private void validateData(ByteBuffer data){
        if(data.limit() != GlobalConstants.COMPRESSED_20MS_AUDIO_SIZE){
            ++mStats.bad_size;
            return;
        }
        short seq = data.getShort(0);
        if( seq != mSequence ){
            ++mStats.bad_seq;
            return;
        }
        for(int i = 0; i< GlobalConstants.COMPRESSED_20MS_AUDIO_SIZE/2; ++i){
            short value = data.getShort();
            if(value != (mSequence + i)){
                ++mStats.bad_content;
                return;
            }
        }
    }

    private void handleData(){
        ++mStats.total;
        ByteBuffer data = mJitterBuffer.poll();
        if(data == null){
            ++mStats.lost;
            ++mStats.consecutive_lost;
            if( mStats.consecutive_lost == JITTER_DEPTH ){
                stop(); // done with this session
            }
        } else {
            validateData(data);
            if(mStats.consecutive_lost != 0){
                if(mStats.consecutive_lost > mStats.max_consecutive_lost){
                    mStats.max_consecutive_lost = mStats.consecutive_lost;
                }
                mStats.consecutive_lost = 0;
            }
        }
        ++mSequence;
    }

    final Runnable mJob = new Runnable(){
        public void run(){
            SpkrNoiseSim.this.handleData();
        }
    };

    private final ScheduledExecutorService mExecutor;

    private final int JITTER_DEPTH = 6;
    private final JitterBuffer<ByteBuffer> mJitterBuffer =
            new JitterBuffer<ByteBuffer>(JITTER_DEPTH, GlobalConstants.CALL_PACKET_INTERVAL, TimeUnit.MILLISECONDS);

    private ScheduledFuture mScheduledJob = null;
    private Listener mListener = null;
    private boolean mRunning = false;
    private boolean mStopped = false;
    private int mSequence = 0;

    public static class Stats{
        public int lost = 0;
        public int consecutive_lost = 0;
        public int max_consecutive_lost = 0;
        public int bad_size = 0;
        public int bad_seq = 0; // bad sequence number
        public int bad_content = 0; // bad content, without looking at the 1st short
        public int total = 0; //including lost and invalid
    };
    private Stats mStats = new Stats();
}
